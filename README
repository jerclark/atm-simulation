ATM project from CSCIE 160 at Harvard Extension

This is not a particularly exciting sample, but I include this because
student projects illustrate design and coding style in a self-contained
package.

To get the overview as well as instructions for build/execution,
check out cscie160/project/doc/index.html.

===========contents of that doc file below===========

Java RMI implementation of an ATM/Bank system that uses remote objects to conducts ATM transactions on accounts held in a bank.

-Included Interfaces: ATM, ATMFactory, Account, Bank, Security, ATMListener
-Included Classes (Bold indicates UnicastRemoteObject subclass): AccountImpl, ATMFactoryImpl, ATMImplementation, ATMServer, BankImpl, SecurityImpl, BankServer, Client, TransactionNotification
-Included Exception Classes: AccountInsufficientFundsException, ATMInsufficientCashException, AuthenticationFailedException, UnauthorizedTransactionException
Design/Implementation Details:

There three main parts to the system: ATMServer, BankServer and Client. See notes below for details.
ATMServer

The ATMServer binds an ATMImplementation to the rmiregistry
ATM (Interface):

-Interface defines methods to perform operations on bank accounts (deposit, withdraw, transfer, getBalance), methods to add and remove ATMListener objects who want to receive notifications about ATM operations, a convenience method to notify all listeners and a method to validate the transaction (authenticate and authorize).The validateTransaction method returns an Account object that can be operated on.
-Defines an enum type "Transaction", that defines the transactions DEPOSIT, WITHDRAW, TRANSFER and BALANCE, and is used in the following places:
   -By the Security interface to determine whether a transaction type is authorized for a given account. I preferred the formal typing of an enum to passing strings to define/retrieve transaction types.
   -By the TransactionNotification class to define formatting for notification strings returned to clients.
ATMImplementation (UnicastRemoteObject):

-Contains the following state members: Cash (cash on hand), a collection of AMTListeners to notify, a reference to the remote Bank and a reference to the remote Security authority. -Constructor initializes cash amount to $500, creates an empty list of listeners, and looks up the Bank and Security objects from the rmiregistry. -Each of the operations that wants to perform a transaction on an Account performs the following steps:
1) Create a transaction notification for the operation.
2) Notify all listeners with that transaction notification
3) Call the validateTransaction method to get the Account from the bank. The validation method calls out to the authenticate and authorize methods on the Security object. If the validation fails, an exception will be thrown - otherwise, we get the Account from the bank
4) Perform the operation on the Account retrieved from the "validateTransaction" method
5) Perform any local state change associated with the transaction (currently, this only happens when we remove cash due to a withdrawl).
ATMFactory (Interface):

-This is the same interface as HW5, except that the getATM() method throws more RMI exceptions because it creates an ATMImplementation whose constructor looks in the registry for Bank and Security objects.
ATMFactoryImpl (UnicastRemoteObject):

-This is the same implementation as HW5, except that the getATM() method throws more RMI exceptions because it creates an ATMImplementation whose constructor looks in the registry for Bank and Security objects. 
BankServer

The BankServer binds a Bank and Security object to the rmiregistry
Bank (Interface):

-Interface defines one method getAccount, that will return an Account object to the calling ATM.
BankImpl (UnicastRemoteObject):

-Initializes accounts and stores them in a hash map. Previously, this was done in the ATMImplementation.
Account (Interface):

-Defines methods for deposit, withdraw, getBalance, and getNumber (which returns the account number).
AccountImpl (UnicastRemoteObject):

-Extends UnicastRemoteObject, as the Account objects are passed remotely from the BankServer to the ATMServer when the ATM performs a transaction.
-Defines methods for deposit, withdraw and getBalance. Throws an AccountInsufficientFundsExeception when a more money is requested for withdrawl than is avaialable.
Security:

-Interface defines two methods, authenticate(AccountInfo info) and authorizeTransaction(AccountInfo info, java.lang.reflect.Method transactionMethod). Methods return void, but throw exceptions when they fail.
SecurityImpl(UnicastRemoteObject):

-Contains authentication ArrayList of AccountInfo members. I'm using an array of AccountInfo objects rather than a map of account numbers to pins, because at some point, theoretically, AccountInfo could include more attributes - and we'd want to check all of them (i.e. check if the AccountInfo objects are equal). An example might be fingerprint scan data for example.
-Contains an authorization map that maps account numbers as keys to an array of authorized ATM.Transaction operations for that account. If the method isn't in the value array, the account is not authorized to perform that operation. For example {000001:[ATM.Transaction.DEPOSIT, ATM.Transaction.WITHDRAW]}.
-Implements the authenticate() and authorizeTransaction() methods declared in the Security interface.
-The authenticate() method takes an AccountInfo object, and checks if the authentication ArrayList contains the passed in AccountInfo object. The hashCode() and equals() methods have been overriden on AccountInfo so that we can compare AccountInfo objects by value since they are created in different remote objects.
-The authorization() method takes an ATM.Transaction and an AccountID to see if the authorization map contains that paring. If it does, the transaction is authorized.
-If authentication fails, throws "AuthenticationFailureException"
-If authorization fails, throws "UnauthorizedTransactionException"
Client

Client (UnicastRemoteObject):

-Subclasses UnicastRemoteObject because once it registers as an ATMlistener on the remote ATM object, the ATM needs to be able to call remotely back to the Client object. -Implements the ATMListener interface (handleTransactionNotification()) so it can display information from the ATM.
-Defines a class method testATM, that will perform test transactions. -main() method does the following:
   -Creates a client object, and registers it as a listener in the ATM    -Executes the static method Client.testATM() method    -Performs UncastRemoteObject.unexportObject(client) to remove the client from the RMI system and terminates the client thread.
Shared

Account Info:

-Data class that wraps Account number and Pin number for security validation.
-Overrides hashMap() and equals() (using the Eclipse generated overrides) so that equality is defined by the value of the member variables. This way, objects in different remote components can validate whether an AccountInfo object is the same as one created somewhere else, given that they have the same accountId and pin.
-Note that the accountId is "final", but the pin isn't. This is because, theoretically, a pin could be changed at some future point.
Transaction Notification:

-Data class containing a Map that pairs account IDs with Transaction types, a transaction type for the notification, and transaction amount info. NOTE: I'm using a map to capture account data because in the case of a Transfer we have two accounts, each with a different transaction (one WITHDRAW and one DEPOSIT). In the case of a non-transfer transaction, the map may be overkill and will be redundant with the transaction parameter on the TransactionNotification, but I thought it was a consistent way to capture the account information for all types of transactions.
-Overrides toString() to return a formatted string with transaction information.
Testing the Simulation

Build the application

-Assuming {src} to be the folder where you have the source: -cd to {src}/cscie160/project, and run 'ant build-jar'.
-create a folder where you want to "unpack" the application to, for example 'mkdir ~/ATM'
-cd into the folder created in the previous step, i.e. 'cd ~/ATM'
-'unpack' the built jar file into your created folder by running: 'jar xf {src}/cscie160/project/build/Project.jar'
-Follow the steps below, considering the "application" folder to be the folder you created above, (i.e. ~/ATM ).
Start the registry

-cd to your "application" folder -run "rmiregistry" from the command line
Start the BankServer:

-In a new shell, cd to your "application" folder
-run java cscie160.project.BankServer
Start the ATMServer:

-In a new shell, cd your "application" folder
-run java cscie160.project.ATMServer
Running the client:

-In another new shell cd your "application" folder
-java cscie160.project.Client
Sample Output
Performing balance inquiry on account: 1
Balance(0000001): 0.0
Performing balance inquiry on account: 2
Balance(0000002): 100.0
Performing balance inquiry on account: 3
Balance(0000003): 500.0
Performing balance inquiry on account: 1
Failed as expected: cscie160.project.AuthenticationFailedException: Authentication Failed.
WITHDRAW $500.0 on account: 2
Failed as expected: cscie160.project.UnauthorizedTransactionException: Not authroized to perform transaction WITHDRAW on account 2
WITHDRAW $50.0 on account: 1
Failed as expected: cscie160.project.AccountInsufficientFundsException: Insufficient funds available (Balance: 0.0) for withdrwal of 50.0 in Account: 1
DEPOSIT $500.0 on account: 1
DEPOSIT $100.0 on account: 2
WITHDRAW $100.0 on account: 1
WITHDRAW $300.0 on account: 3
WITHDRAW $200.0 on account: 1
Failed as expected: cscie160.project.ATMInsufficientCashException: I'm sorry, but I, your humble ATM, don't have that much cash right now!
TRANSFER $100.0 FROM account: 1 TO account: 2
Performing balance inquiry on account: 1
Balance(0000001): 300.0
Performing balance inquiry on account: 2
Balance(0000002): 300.0
Performing balance inquiry on account: 3
Balance(0000003): 200.0